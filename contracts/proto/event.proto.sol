// File automatically generated by protoc-gen-sol 
// SPDX-License-Identifier: CC0
pragma solidity >=0.6.0 <8.0.0;
pragma experimental ABIEncoderV2;

import "@lazyledger/protobuf3-solidity-lib/contracts/ProtobufLib.sol";

enum DomainEventType { UNSPECIFIED, NFT_MINTED, NFT_TRANSFERED, AMM_CREATED, LIQUIDITY_ADDED, LIQUIDITY_REMOVED, TOKENS_SWAPPED, FUNDS_DEPOSITED, FUNDS_WITHDRAWN }

struct DomainEvent {
    uint64 evnt_idx;
    DomainEventType evnt_type;
    bytes evnt_payload;
}

library DomainEventCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, DomainEvent memory) {
        // Message instance
        DomainEvent memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 3) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 3) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, DomainEvent memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 3) {
            bool success;
            (success, pos) = decode_3(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // DomainEvent.evnt_idx
    function decode_1(uint64 pos, bytes memory buf, DomainEvent memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.evnt_idx = v;

        return (true, pos);
    }

    // DomainEvent.evnt_type
    function decode_2(uint64 pos, bytes memory buf, DomainEvent memory instance) internal pure returns (bool, uint64) {
        bool success;

        int32 v;
        (success, pos, v) = ProtobufLib.decode_enum(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        // Check that value is within enum range
        if (v < 0 || v > 8) {
            return (false, pos);
        }

        instance.evnt_type = DomainEventType(v);

        return (true, pos);
    }

    // DomainEvent.evnt_payload
    function decode_3(uint64 pos, bytes memory buf, DomainEvent memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.evnt_payload = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.evnt_payload[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // Holds encoded version of message
    struct DomainEvent__Encoded {
        bytes evnt_idx__Key;
        bytes evnt_idx;
        bytes evnt_type__Key;
        bytes evnt_type;
        bytes evnt_payload__Key;
        bytes evnt_payload__Length;
        bytes evnt_payload;
    }

    // Holds encoded version of nested message
    struct DomainEvent__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(DomainEvent memory instance) internal pure returns (bytes memory) {
        DomainEvent__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding evnt_idx if default value
        if (uint64(instance.evnt_idx) != 0) {
            // Encode key for evnt_idx
            encodedInstance.evnt_idx__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.Varint));
            // Encode evnt_idx
            encodedInstance.evnt_idx = ProtobufLib.encode_uint64(instance.evnt_idx);
        }

        // Omit encoding evnt_type if default value
        if (uint64(instance.evnt_type) != 0) {
            // Encode key for evnt_type
            encodedInstance.evnt_type__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.Varint));
            // Encode evnt_type
            int256 enum_val_i256 = int256(uint(instance.evnt_type));
            int32 enum_val_i32 = int32(int(enum_val_i256));
            encodedInstance.evnt_type = ProtobufLib.encode_int32(enum_val_i32);
        }

        // Omit encoding evnt_payload if default value
        if (bytes(instance.evnt_payload).length > 0) {
            // Encode key for evnt_payload
            encodedInstance.evnt_payload__Key = ProtobufLib.encode_key(3, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode evnt_payload
            encodedInstance.evnt_payload__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.evnt_payload).length));
            encodedInstance.evnt_payload = bytes(instance.evnt_payload);
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.evnt_idx__Key.length);
        len += uint64(encodedInstance.evnt_idx.length);
        len += uint64(encodedInstance.evnt_type__Key.length);
        len += uint64(encodedInstance.evnt_type.length);
        len += uint64(encodedInstance.evnt_payload__Key.length);
        len += uint64(encodedInstance.evnt_payload__Length.length);
        len += uint64(encodedInstance.evnt_payload.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.evnt_idx__Key.length) {
            finalEncoded[index++] = encodedInstance.evnt_idx__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.evnt_idx.length) {
            finalEncoded[index++] = encodedInstance.evnt_idx[j++];
        }
        j = 0;
        while (j < encodedInstance.evnt_type__Key.length) {
            finalEncoded[index++] = encodedInstance.evnt_type__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.evnt_type.length) {
            finalEncoded[index++] = encodedInstance.evnt_type[j++];
        }
        j = 0;
        while (j < encodedInstance.evnt_payload__Key.length) {
            finalEncoded[index++] = encodedInstance.evnt_payload__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.evnt_payload__Length.length) {
            finalEncoded[index++] = encodedInstance.evnt_payload__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.evnt_payload.length) {
            finalEncoded[index++] = encodedInstance.evnt_payload[j++];
        }

        return finalEncoded;
    }

    // Encode a nested DomainEvent, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, DomainEvent memory instance) internal pure returns (DomainEvent__Encoded__Nested memory) {
        DomainEvent__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }

}

struct NFTMintedPayload {
    bytes hash;
    bytes owner;
}

library NFTMintedPayloadCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, NFTMintedPayload memory) {
        // Message instance
        NFTMintedPayload memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 2) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, NFTMintedPayload memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // NFTMintedPayload.hash
    function decode_1(uint64 pos, bytes memory buf, NFTMintedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.hash = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.hash[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // NFTMintedPayload.owner
    function decode_2(uint64 pos, bytes memory buf, NFTMintedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.owner = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.owner[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // Holds encoded version of message
    struct NFTMintedPayload__Encoded {
        bytes hash__Key;
        bytes hash__Length;
        bytes hash;
        bytes owner__Key;
        bytes owner__Length;
        bytes owner;
    }

    // Holds encoded version of nested message
    struct NFTMintedPayload__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(NFTMintedPayload memory instance) internal pure returns (bytes memory) {
        NFTMintedPayload__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding hash if default value
        if (bytes(instance.hash).length > 0) {
            // Encode key for hash
            encodedInstance.hash__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode hash
            encodedInstance.hash__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.hash).length));
            encodedInstance.hash = bytes(instance.hash);
        }

        // Omit encoding owner if default value
        if (bytes(instance.owner).length > 0) {
            // Encode key for owner
            encodedInstance.owner__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode owner
            encodedInstance.owner__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.owner).length));
            encodedInstance.owner = bytes(instance.owner);
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.hash__Key.length);
        len += uint64(encodedInstance.hash__Length.length);
        len += uint64(encodedInstance.hash.length);
        len += uint64(encodedInstance.owner__Key.length);
        len += uint64(encodedInstance.owner__Length.length);
        len += uint64(encodedInstance.owner.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.hash__Key.length) {
            finalEncoded[index++] = encodedInstance.hash__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.hash__Length.length) {
            finalEncoded[index++] = encodedInstance.hash__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.hash.length) {
            finalEncoded[index++] = encodedInstance.hash[j++];
        }
        j = 0;
        while (j < encodedInstance.owner__Key.length) {
            finalEncoded[index++] = encodedInstance.owner__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.owner__Length.length) {
            finalEncoded[index++] = encodedInstance.owner__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.owner.length) {
            finalEncoded[index++] = encodedInstance.owner[j++];
        }

        return finalEncoded;
    }

    // Encode a nested NFTMintedPayload, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, NFTMintedPayload memory instance) internal pure returns (NFTMintedPayload__Encoded__Nested memory) {
        NFTMintedPayload__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }

}

struct NFTTransferedPayload {
    bytes hash;
    bytes from;
    bytes to;
}

library NFTTransferedPayloadCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, NFTTransferedPayload memory) {
        // Message instance
        NFTTransferedPayload memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 3) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 3) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, NFTTransferedPayload memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 3) {
            bool success;
            (success, pos) = decode_3(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // NFTTransferedPayload.hash
    function decode_1(uint64 pos, bytes memory buf, NFTTransferedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.hash = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.hash[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // NFTTransferedPayload.from
    function decode_2(uint64 pos, bytes memory buf, NFTTransferedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.from = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.from[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // NFTTransferedPayload.to
    function decode_3(uint64 pos, bytes memory buf, NFTTransferedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.to = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.to[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // Holds encoded version of message
    struct NFTTransferedPayload__Encoded {
        bytes hash__Key;
        bytes hash__Length;
        bytes hash;
        bytes from__Key;
        bytes from__Length;
        bytes from;
        bytes to__Key;
        bytes to__Length;
        bytes to;
    }

    // Holds encoded version of nested message
    struct NFTTransferedPayload__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(NFTTransferedPayload memory instance) internal pure returns (bytes memory) {
        NFTTransferedPayload__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding hash if default value
        if (bytes(instance.hash).length > 0) {
            // Encode key for hash
            encodedInstance.hash__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode hash
            encodedInstance.hash__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.hash).length));
            encodedInstance.hash = bytes(instance.hash);
        }

        // Omit encoding from if default value
        if (bytes(instance.from).length > 0) {
            // Encode key for from
            encodedInstance.from__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode from
            encodedInstance.from__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.from).length));
            encodedInstance.from = bytes(instance.from);
        }

        // Omit encoding to if default value
        if (bytes(instance.to).length > 0) {
            // Encode key for to
            encodedInstance.to__Key = ProtobufLib.encode_key(3, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode to
            encodedInstance.to__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.to).length));
            encodedInstance.to = bytes(instance.to);
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.hash__Key.length);
        len += uint64(encodedInstance.hash__Length.length);
        len += uint64(encodedInstance.hash.length);
        len += uint64(encodedInstance.from__Key.length);
        len += uint64(encodedInstance.from__Length.length);
        len += uint64(encodedInstance.from.length);
        len += uint64(encodedInstance.to__Key.length);
        len += uint64(encodedInstance.to__Length.length);
        len += uint64(encodedInstance.to.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.hash__Key.length) {
            finalEncoded[index++] = encodedInstance.hash__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.hash__Length.length) {
            finalEncoded[index++] = encodedInstance.hash__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.hash.length) {
            finalEncoded[index++] = encodedInstance.hash[j++];
        }
        j = 0;
        while (j < encodedInstance.from__Key.length) {
            finalEncoded[index++] = encodedInstance.from__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.from__Length.length) {
            finalEncoded[index++] = encodedInstance.from__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.from.length) {
            finalEncoded[index++] = encodedInstance.from[j++];
        }
        j = 0;
        while (j < encodedInstance.to__Key.length) {
            finalEncoded[index++] = encodedInstance.to__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.to__Length.length) {
            finalEncoded[index++] = encodedInstance.to__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.to.length) {
            finalEncoded[index++] = encodedInstance.to[j++];
        }

        return finalEncoded;
    }

    // Encode a nested NFTTransferedPayload, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, NFTTransferedPayload memory instance) internal pure returns (NFTTransferedPayload__Encoded__Nested memory) {
        NFTTransferedPayload__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }

}

struct AMMCreatedPayload {
    bytes asset1;
    bytes asset2;
    uint64 supply1;
    uint64 supply2;
    bytes owner;
}

library AMMCreatedPayloadCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, AMMCreatedPayload memory) {
        // Message instance
        AMMCreatedPayload memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 5) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 3) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 4) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 5) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, AMMCreatedPayload memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 3) {
            bool success;
            (success, pos) = decode_3(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 4) {
            bool success;
            (success, pos) = decode_4(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 5) {
            bool success;
            (success, pos) = decode_5(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // AMMCreatedPayload.asset1
    function decode_1(uint64 pos, bytes memory buf, AMMCreatedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.asset1 = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.asset1[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // AMMCreatedPayload.asset2
    function decode_2(uint64 pos, bytes memory buf, AMMCreatedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.asset2 = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.asset2[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // AMMCreatedPayload.supply1
    function decode_3(uint64 pos, bytes memory buf, AMMCreatedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.supply1 = v;

        return (true, pos);
    }

    // AMMCreatedPayload.supply2
    function decode_4(uint64 pos, bytes memory buf, AMMCreatedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.supply2 = v;

        return (true, pos);
    }

    // AMMCreatedPayload.owner
    function decode_5(uint64 pos, bytes memory buf, AMMCreatedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.owner = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.owner[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // Holds encoded version of message
    struct AMMCreatedPayload__Encoded {
        bytes asset1__Key;
        bytes asset1__Length;
        bytes asset1;
        bytes asset2__Key;
        bytes asset2__Length;
        bytes asset2;
        bytes supply1__Key;
        bytes supply1;
        bytes supply2__Key;
        bytes supply2;
        bytes owner__Key;
        bytes owner__Length;
        bytes owner;
    }

    // Holds encoded version of nested message
    struct AMMCreatedPayload__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(AMMCreatedPayload memory instance) internal pure returns (bytes memory) {
        AMMCreatedPayload__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding asset1 if default value
        if (bytes(instance.asset1).length > 0) {
            // Encode key for asset1
            encodedInstance.asset1__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode asset1
            encodedInstance.asset1__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.asset1).length));
            encodedInstance.asset1 = bytes(instance.asset1);
        }

        // Omit encoding asset2 if default value
        if (bytes(instance.asset2).length > 0) {
            // Encode key for asset2
            encodedInstance.asset2__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode asset2
            encodedInstance.asset2__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.asset2).length));
            encodedInstance.asset2 = bytes(instance.asset2);
        }

        // Omit encoding supply1 if default value
        if (uint64(instance.supply1) != 0) {
            // Encode key for supply1
            encodedInstance.supply1__Key = ProtobufLib.encode_key(3, uint64(ProtobufLib.WireType.Varint));
            // Encode supply1
            encodedInstance.supply1 = ProtobufLib.encode_uint64(instance.supply1);
        }

        // Omit encoding supply2 if default value
        if (uint64(instance.supply2) != 0) {
            // Encode key for supply2
            encodedInstance.supply2__Key = ProtobufLib.encode_key(4, uint64(ProtobufLib.WireType.Varint));
            // Encode supply2
            encodedInstance.supply2 = ProtobufLib.encode_uint64(instance.supply2);
        }

        // Omit encoding owner if default value
        if (bytes(instance.owner).length > 0) {
            // Encode key for owner
            encodedInstance.owner__Key = ProtobufLib.encode_key(5, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode owner
            encodedInstance.owner__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.owner).length));
            encodedInstance.owner = bytes(instance.owner);
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.asset1__Key.length);
        len += uint64(encodedInstance.asset1__Length.length);
        len += uint64(encodedInstance.asset1.length);
        len += uint64(encodedInstance.asset2__Key.length);
        len += uint64(encodedInstance.asset2__Length.length);
        len += uint64(encodedInstance.asset2.length);
        len += uint64(encodedInstance.supply1__Key.length);
        len += uint64(encodedInstance.supply1.length);
        len += uint64(encodedInstance.supply2__Key.length);
        len += uint64(encodedInstance.supply2.length);
        len += uint64(encodedInstance.owner__Key.length);
        len += uint64(encodedInstance.owner__Length.length);
        len += uint64(encodedInstance.owner.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.asset1__Key.length) {
            finalEncoded[index++] = encodedInstance.asset1__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.asset1__Length.length) {
            finalEncoded[index++] = encodedInstance.asset1__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.asset1.length) {
            finalEncoded[index++] = encodedInstance.asset1[j++];
        }
        j = 0;
        while (j < encodedInstance.asset2__Key.length) {
            finalEncoded[index++] = encodedInstance.asset2__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.asset2__Length.length) {
            finalEncoded[index++] = encodedInstance.asset2__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.asset2.length) {
            finalEncoded[index++] = encodedInstance.asset2[j++];
        }
        j = 0;
        while (j < encodedInstance.supply1__Key.length) {
            finalEncoded[index++] = encodedInstance.supply1__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.supply1.length) {
            finalEncoded[index++] = encodedInstance.supply1[j++];
        }
        j = 0;
        while (j < encodedInstance.supply2__Key.length) {
            finalEncoded[index++] = encodedInstance.supply2__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.supply2.length) {
            finalEncoded[index++] = encodedInstance.supply2[j++];
        }
        j = 0;
        while (j < encodedInstance.owner__Key.length) {
            finalEncoded[index++] = encodedInstance.owner__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.owner__Length.length) {
            finalEncoded[index++] = encodedInstance.owner__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.owner.length) {
            finalEncoded[index++] = encodedInstance.owner[j++];
        }

        return finalEncoded;
    }

    // Encode a nested AMMCreatedPayload, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, AMMCreatedPayload memory instance) internal pure returns (AMMCreatedPayload__Encoded__Nested memory) {
        AMMCreatedPayload__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }

}

struct LiquidityAddedPayload {
    uint64 amount1;
    uint64 amount2;
    bytes account;
}

library LiquidityAddedPayloadCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, LiquidityAddedPayload memory) {
        // Message instance
        LiquidityAddedPayload memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 3) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 3) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, LiquidityAddedPayload memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 3) {
            bool success;
            (success, pos) = decode_3(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // LiquidityAddedPayload.amount1
    function decode_1(uint64 pos, bytes memory buf, LiquidityAddedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.amount1 = v;

        return (true, pos);
    }

    // LiquidityAddedPayload.amount2
    function decode_2(uint64 pos, bytes memory buf, LiquidityAddedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.amount2 = v;

        return (true, pos);
    }

    // LiquidityAddedPayload.account
    function decode_3(uint64 pos, bytes memory buf, LiquidityAddedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.account = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.account[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // Holds encoded version of message
    struct LiquidityAddedPayload__Encoded {
        bytes amount1__Key;
        bytes amount1;
        bytes amount2__Key;
        bytes amount2;
        bytes account__Key;
        bytes account__Length;
        bytes account;
    }

    // Holds encoded version of nested message
    struct LiquidityAddedPayload__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(LiquidityAddedPayload memory instance) internal pure returns (bytes memory) {
        LiquidityAddedPayload__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding amount1 if default value
        if (uint64(instance.amount1) != 0) {
            // Encode key for amount1
            encodedInstance.amount1__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.Varint));
            // Encode amount1
            encodedInstance.amount1 = ProtobufLib.encode_uint64(instance.amount1);
        }

        // Omit encoding amount2 if default value
        if (uint64(instance.amount2) != 0) {
            // Encode key for amount2
            encodedInstance.amount2__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.Varint));
            // Encode amount2
            encodedInstance.amount2 = ProtobufLib.encode_uint64(instance.amount2);
        }

        // Omit encoding account if default value
        if (bytes(instance.account).length > 0) {
            // Encode key for account
            encodedInstance.account__Key = ProtobufLib.encode_key(3, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode account
            encodedInstance.account__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.account).length));
            encodedInstance.account = bytes(instance.account);
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.amount1__Key.length);
        len += uint64(encodedInstance.amount1.length);
        len += uint64(encodedInstance.amount2__Key.length);
        len += uint64(encodedInstance.amount2.length);
        len += uint64(encodedInstance.account__Key.length);
        len += uint64(encodedInstance.account__Length.length);
        len += uint64(encodedInstance.account.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.amount1__Key.length) {
            finalEncoded[index++] = encodedInstance.amount1__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.amount1.length) {
            finalEncoded[index++] = encodedInstance.amount1[j++];
        }
        j = 0;
        while (j < encodedInstance.amount2__Key.length) {
            finalEncoded[index++] = encodedInstance.amount2__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.amount2.length) {
            finalEncoded[index++] = encodedInstance.amount2[j++];
        }
        j = 0;
        while (j < encodedInstance.account__Key.length) {
            finalEncoded[index++] = encodedInstance.account__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.account__Length.length) {
            finalEncoded[index++] = encodedInstance.account__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.account.length) {
            finalEncoded[index++] = encodedInstance.account[j++];
        }

        return finalEncoded;
    }

    // Encode a nested LiquidityAddedPayload, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, LiquidityAddedPayload memory instance) internal pure returns (LiquidityAddedPayload__Encoded__Nested memory) {
        LiquidityAddedPayload__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }

}

struct LiquidityRemovedPayload {
    uint64 shares;
    uint64 amount1;
    uint64 amount2;
    bytes account;
}

library LiquidityRemovedPayloadCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, LiquidityRemovedPayload memory) {
        // Message instance
        LiquidityRemovedPayload memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 4) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 3) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 4) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, LiquidityRemovedPayload memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 3) {
            bool success;
            (success, pos) = decode_3(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 4) {
            bool success;
            (success, pos) = decode_4(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // LiquidityRemovedPayload.shares
    function decode_1(uint64 pos, bytes memory buf, LiquidityRemovedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.shares = v;

        return (true, pos);
    }

    // LiquidityRemovedPayload.amount1
    function decode_2(uint64 pos, bytes memory buf, LiquidityRemovedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.amount1 = v;

        return (true, pos);
    }

    // LiquidityRemovedPayload.amount2
    function decode_3(uint64 pos, bytes memory buf, LiquidityRemovedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.amount2 = v;

        return (true, pos);
    }

    // LiquidityRemovedPayload.account
    function decode_4(uint64 pos, bytes memory buf, LiquidityRemovedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.account = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.account[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // Holds encoded version of message
    struct LiquidityRemovedPayload__Encoded {
        bytes shares__Key;
        bytes shares;
        bytes amount1__Key;
        bytes amount1;
        bytes amount2__Key;
        bytes amount2;
        bytes account__Key;
        bytes account__Length;
        bytes account;
    }

    // Holds encoded version of nested message
    struct LiquidityRemovedPayload__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(LiquidityRemovedPayload memory instance) internal pure returns (bytes memory) {
        LiquidityRemovedPayload__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding shares if default value
        if (uint64(instance.shares) != 0) {
            // Encode key for shares
            encodedInstance.shares__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.Varint));
            // Encode shares
            encodedInstance.shares = ProtobufLib.encode_uint64(instance.shares);
        }

        // Omit encoding amount1 if default value
        if (uint64(instance.amount1) != 0) {
            // Encode key for amount1
            encodedInstance.amount1__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.Varint));
            // Encode amount1
            encodedInstance.amount1 = ProtobufLib.encode_uint64(instance.amount1);
        }

        // Omit encoding amount2 if default value
        if (uint64(instance.amount2) != 0) {
            // Encode key for amount2
            encodedInstance.amount2__Key = ProtobufLib.encode_key(3, uint64(ProtobufLib.WireType.Varint));
            // Encode amount2
            encodedInstance.amount2 = ProtobufLib.encode_uint64(instance.amount2);
        }

        // Omit encoding account if default value
        if (bytes(instance.account).length > 0) {
            // Encode key for account
            encodedInstance.account__Key = ProtobufLib.encode_key(4, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode account
            encodedInstance.account__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.account).length));
            encodedInstance.account = bytes(instance.account);
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.shares__Key.length);
        len += uint64(encodedInstance.shares.length);
        len += uint64(encodedInstance.amount1__Key.length);
        len += uint64(encodedInstance.amount1.length);
        len += uint64(encodedInstance.amount2__Key.length);
        len += uint64(encodedInstance.amount2.length);
        len += uint64(encodedInstance.account__Key.length);
        len += uint64(encodedInstance.account__Length.length);
        len += uint64(encodedInstance.account.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.shares__Key.length) {
            finalEncoded[index++] = encodedInstance.shares__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.shares.length) {
            finalEncoded[index++] = encodedInstance.shares[j++];
        }
        j = 0;
        while (j < encodedInstance.amount1__Key.length) {
            finalEncoded[index++] = encodedInstance.amount1__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.amount1.length) {
            finalEncoded[index++] = encodedInstance.amount1[j++];
        }
        j = 0;
        while (j < encodedInstance.amount2__Key.length) {
            finalEncoded[index++] = encodedInstance.amount2__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.amount2.length) {
            finalEncoded[index++] = encodedInstance.amount2[j++];
        }
        j = 0;
        while (j < encodedInstance.account__Key.length) {
            finalEncoded[index++] = encodedInstance.account__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.account__Length.length) {
            finalEncoded[index++] = encodedInstance.account__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.account.length) {
            finalEncoded[index++] = encodedInstance.account[j++];
        }

        return finalEncoded;
    }

    // Encode a nested LiquidityRemovedPayload, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, LiquidityRemovedPayload memory instance) internal pure returns (LiquidityRemovedPayload__Encoded__Nested memory) {
        LiquidityRemovedPayload__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }

}

struct TokensSwapedPayload {
    uint64 amount_from;
    bytes asset_from;
    uint64 amount_to;
    bytes asset_to;
    bytes account;
}

library TokensSwapedPayloadCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, TokensSwapedPayload memory) {
        // Message instance
        TokensSwapedPayload memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 5) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 3) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 4) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 5) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, TokensSwapedPayload memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 3) {
            bool success;
            (success, pos) = decode_3(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 4) {
            bool success;
            (success, pos) = decode_4(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 5) {
            bool success;
            (success, pos) = decode_5(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // TokensSwapedPayload.amount_from
    function decode_1(uint64 pos, bytes memory buf, TokensSwapedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.amount_from = v;

        return (true, pos);
    }

    // TokensSwapedPayload.asset_from
    function decode_2(uint64 pos, bytes memory buf, TokensSwapedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.asset_from = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.asset_from[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // TokensSwapedPayload.amount_to
    function decode_3(uint64 pos, bytes memory buf, TokensSwapedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.amount_to = v;

        return (true, pos);
    }

    // TokensSwapedPayload.asset_to
    function decode_4(uint64 pos, bytes memory buf, TokensSwapedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.asset_to = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.asset_to[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // TokensSwapedPayload.account
    function decode_5(uint64 pos, bytes memory buf, TokensSwapedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.account = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.account[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // Holds encoded version of message
    struct TokensSwapedPayload__Encoded {
        bytes amount_from__Key;
        bytes amount_from;
        bytes asset_from__Key;
        bytes asset_from__Length;
        bytes asset_from;
        bytes amount_to__Key;
        bytes amount_to;
        bytes asset_to__Key;
        bytes asset_to__Length;
        bytes asset_to;
        bytes account__Key;
        bytes account__Length;
        bytes account;
    }

    // Holds encoded version of nested message
    struct TokensSwapedPayload__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(TokensSwapedPayload memory instance) internal pure returns (bytes memory) {
        TokensSwapedPayload__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding amount_from if default value
        if (uint64(instance.amount_from) != 0) {
            // Encode key for amount_from
            encodedInstance.amount_from__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.Varint));
            // Encode amount_from
            encodedInstance.amount_from = ProtobufLib.encode_uint64(instance.amount_from);
        }

        // Omit encoding asset_from if default value
        if (bytes(instance.asset_from).length > 0) {
            // Encode key for asset_from
            encodedInstance.asset_from__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode asset_from
            encodedInstance.asset_from__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.asset_from).length));
            encodedInstance.asset_from = bytes(instance.asset_from);
        }

        // Omit encoding amount_to if default value
        if (uint64(instance.amount_to) != 0) {
            // Encode key for amount_to
            encodedInstance.amount_to__Key = ProtobufLib.encode_key(3, uint64(ProtobufLib.WireType.Varint));
            // Encode amount_to
            encodedInstance.amount_to = ProtobufLib.encode_uint64(instance.amount_to);
        }

        // Omit encoding asset_to if default value
        if (bytes(instance.asset_to).length > 0) {
            // Encode key for asset_to
            encodedInstance.asset_to__Key = ProtobufLib.encode_key(4, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode asset_to
            encodedInstance.asset_to__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.asset_to).length));
            encodedInstance.asset_to = bytes(instance.asset_to);
        }

        // Omit encoding account if default value
        if (bytes(instance.account).length > 0) {
            // Encode key for account
            encodedInstance.account__Key = ProtobufLib.encode_key(5, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode account
            encodedInstance.account__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.account).length));
            encodedInstance.account = bytes(instance.account);
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.amount_from__Key.length);
        len += uint64(encodedInstance.amount_from.length);
        len += uint64(encodedInstance.asset_from__Key.length);
        len += uint64(encodedInstance.asset_from__Length.length);
        len += uint64(encodedInstance.asset_from.length);
        len += uint64(encodedInstance.amount_to__Key.length);
        len += uint64(encodedInstance.amount_to.length);
        len += uint64(encodedInstance.asset_to__Key.length);
        len += uint64(encodedInstance.asset_to__Length.length);
        len += uint64(encodedInstance.asset_to.length);
        len += uint64(encodedInstance.account__Key.length);
        len += uint64(encodedInstance.account__Length.length);
        len += uint64(encodedInstance.account.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.amount_from__Key.length) {
            finalEncoded[index++] = encodedInstance.amount_from__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.amount_from.length) {
            finalEncoded[index++] = encodedInstance.amount_from[j++];
        }
        j = 0;
        while (j < encodedInstance.asset_from__Key.length) {
            finalEncoded[index++] = encodedInstance.asset_from__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.asset_from__Length.length) {
            finalEncoded[index++] = encodedInstance.asset_from__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.asset_from.length) {
            finalEncoded[index++] = encodedInstance.asset_from[j++];
        }
        j = 0;
        while (j < encodedInstance.amount_to__Key.length) {
            finalEncoded[index++] = encodedInstance.amount_to__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.amount_to.length) {
            finalEncoded[index++] = encodedInstance.amount_to[j++];
        }
        j = 0;
        while (j < encodedInstance.asset_to__Key.length) {
            finalEncoded[index++] = encodedInstance.asset_to__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.asset_to__Length.length) {
            finalEncoded[index++] = encodedInstance.asset_to__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.asset_to.length) {
            finalEncoded[index++] = encodedInstance.asset_to[j++];
        }
        j = 0;
        while (j < encodedInstance.account__Key.length) {
            finalEncoded[index++] = encodedInstance.account__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.account__Length.length) {
            finalEncoded[index++] = encodedInstance.account__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.account.length) {
            finalEncoded[index++] = encodedInstance.account[j++];
        }

        return finalEncoded;
    }

    // Encode a nested TokensSwapedPayload, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, TokensSwapedPayload memory instance) internal pure returns (TokensSwapedPayload__Encoded__Nested memory) {
        TokensSwapedPayload__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }

}

struct FundsWithdrawnPayload {
    bytes asset;
    uint64 amount;
    bytes account;
}

library FundsWithdrawnPayloadCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, FundsWithdrawnPayload memory) {
        // Message instance
        FundsWithdrawnPayload memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 3) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 3) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, FundsWithdrawnPayload memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 3) {
            bool success;
            (success, pos) = decode_3(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // FundsWithdrawnPayload.asset
    function decode_1(uint64 pos, bytes memory buf, FundsWithdrawnPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.asset = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.asset[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // FundsWithdrawnPayload.amount
    function decode_2(uint64 pos, bytes memory buf, FundsWithdrawnPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.amount = v;

        return (true, pos);
    }

    // FundsWithdrawnPayload.account
    function decode_3(uint64 pos, bytes memory buf, FundsWithdrawnPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.account = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.account[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // Holds encoded version of message
    struct FundsWithdrawnPayload__Encoded {
        bytes asset__Key;
        bytes asset__Length;
        bytes asset;
        bytes amount__Key;
        bytes amount;
        bytes account__Key;
        bytes account__Length;
        bytes account;
    }

    // Holds encoded version of nested message
    struct FundsWithdrawnPayload__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(FundsWithdrawnPayload memory instance) internal pure returns (bytes memory) {
        FundsWithdrawnPayload__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding asset if default value
        if (bytes(instance.asset).length > 0) {
            // Encode key for asset
            encodedInstance.asset__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode asset
            encodedInstance.asset__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.asset).length));
            encodedInstance.asset = bytes(instance.asset);
        }

        // Omit encoding amount if default value
        if (uint64(instance.amount) != 0) {
            // Encode key for amount
            encodedInstance.amount__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.Varint));
            // Encode amount
            encodedInstance.amount = ProtobufLib.encode_uint64(instance.amount);
        }

        // Omit encoding account if default value
        if (bytes(instance.account).length > 0) {
            // Encode key for account
            encodedInstance.account__Key = ProtobufLib.encode_key(3, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode account
            encodedInstance.account__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.account).length));
            encodedInstance.account = bytes(instance.account);
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.asset__Key.length);
        len += uint64(encodedInstance.asset__Length.length);
        len += uint64(encodedInstance.asset.length);
        len += uint64(encodedInstance.amount__Key.length);
        len += uint64(encodedInstance.amount.length);
        len += uint64(encodedInstance.account__Key.length);
        len += uint64(encodedInstance.account__Length.length);
        len += uint64(encodedInstance.account.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.asset__Key.length) {
            finalEncoded[index++] = encodedInstance.asset__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.asset__Length.length) {
            finalEncoded[index++] = encodedInstance.asset__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.asset.length) {
            finalEncoded[index++] = encodedInstance.asset[j++];
        }
        j = 0;
        while (j < encodedInstance.amount__Key.length) {
            finalEncoded[index++] = encodedInstance.amount__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.amount.length) {
            finalEncoded[index++] = encodedInstance.amount[j++];
        }
        j = 0;
        while (j < encodedInstance.account__Key.length) {
            finalEncoded[index++] = encodedInstance.account__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.account__Length.length) {
            finalEncoded[index++] = encodedInstance.account__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.account.length) {
            finalEncoded[index++] = encodedInstance.account[j++];
        }

        return finalEncoded;
    }

    // Encode a nested FundsWithdrawnPayload, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, FundsWithdrawnPayload memory instance) internal pure returns (FundsWithdrawnPayload__Encoded__Nested memory) {
        FundsWithdrawnPayload__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }

}

struct FundsDepositedPayload {
    bytes asset;
    uint64 amount;
    bytes account;
}

library FundsDepositedPayloadCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, FundsDepositedPayload memory) {
        // Message instance
        FundsDepositedPayload memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 3) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 3) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, FundsDepositedPayload memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 3) {
            bool success;
            (success, pos) = decode_3(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // FundsDepositedPayload.asset
    function decode_1(uint64 pos, bytes memory buf, FundsDepositedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.asset = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.asset[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // FundsDepositedPayload.amount
    function decode_2(uint64 pos, bytes memory buf, FundsDepositedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.amount = v;

        return (true, pos);
    }

    // FundsDepositedPayload.account
    function decode_3(uint64 pos, bytes memory buf, FundsDepositedPayload memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.account = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.account[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // Holds encoded version of message
    struct FundsDepositedPayload__Encoded {
        bytes asset__Key;
        bytes asset__Length;
        bytes asset;
        bytes amount__Key;
        bytes amount;
        bytes account__Key;
        bytes account__Length;
        bytes account;
    }

    // Holds encoded version of nested message
    struct FundsDepositedPayload__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(FundsDepositedPayload memory instance) internal pure returns (bytes memory) {
        FundsDepositedPayload__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding asset if default value
        if (bytes(instance.asset).length > 0) {
            // Encode key for asset
            encodedInstance.asset__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode asset
            encodedInstance.asset__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.asset).length));
            encodedInstance.asset = bytes(instance.asset);
        }

        // Omit encoding amount if default value
        if (uint64(instance.amount) != 0) {
            // Encode key for amount
            encodedInstance.amount__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.Varint));
            // Encode amount
            encodedInstance.amount = ProtobufLib.encode_uint64(instance.amount);
        }

        // Omit encoding account if default value
        if (bytes(instance.account).length > 0) {
            // Encode key for account
            encodedInstance.account__Key = ProtobufLib.encode_key(3, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode account
            encodedInstance.account__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.account).length));
            encodedInstance.account = bytes(instance.account);
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.asset__Key.length);
        len += uint64(encodedInstance.asset__Length.length);
        len += uint64(encodedInstance.asset.length);
        len += uint64(encodedInstance.amount__Key.length);
        len += uint64(encodedInstance.amount.length);
        len += uint64(encodedInstance.account__Key.length);
        len += uint64(encodedInstance.account__Length.length);
        len += uint64(encodedInstance.account.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.asset__Key.length) {
            finalEncoded[index++] = encodedInstance.asset__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.asset__Length.length) {
            finalEncoded[index++] = encodedInstance.asset__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.asset.length) {
            finalEncoded[index++] = encodedInstance.asset[j++];
        }
        j = 0;
        while (j < encodedInstance.amount__Key.length) {
            finalEncoded[index++] = encodedInstance.amount__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.amount.length) {
            finalEncoded[index++] = encodedInstance.amount[j++];
        }
        j = 0;
        while (j < encodedInstance.account__Key.length) {
            finalEncoded[index++] = encodedInstance.account__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.account__Length.length) {
            finalEncoded[index++] = encodedInstance.account__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.account.length) {
            finalEncoded[index++] = encodedInstance.account[j++];
        }

        return finalEncoded;
    }

    // Encode a nested FundsDepositedPayload, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, FundsDepositedPayload memory instance) internal pure returns (FundsDepositedPayload__Encoded__Nested memory) {
        FundsDepositedPayload__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }

}

